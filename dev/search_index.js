var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = NeighborhoodApproximationIndex","category":"page"},{"location":"#NeighborhoodApproximationIndex","page":"Home","title":"NeighborhoodApproximationIndex","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [NeighborhoodApproximationIndex]","category":"page"},{"location":"#NeighborhoodApproximationIndex.DistanceOnTopKOrdering","page":"Home","title":"NeighborhoodApproximationIndex.DistanceOnTopKOrdering","text":"struct DistanceOnTopKOrdering <: KnrOrderingStrategy\n    top::Int\nend\n\nUsed as ordering parameter of KnrIndex specifies that only the top elements are evaluated against the distance metric. Useful for very costly distance functions. If you are in doubt please use DistanceOrdering instead.\n\n\n\n\n\n","category":"type"},{"location":"#NeighborhoodApproximationIndex.DistanceOrdering","page":"Home","title":"NeighborhoodApproximationIndex.DistanceOrdering","text":"struct DistanceOrdering <: KnrOrderingStrategy end\n\nUsed as ordering parameter of KnrIndex specifies that each object u found by the inverted index will be evaluated against a given query. This is the default ordering strategy.\n\n\n\n\n\n","category":"type"},{"location":"#NeighborhoodApproximationIndex.InternalDistanceOrdering","page":"Home","title":"NeighborhoodApproximationIndex.InternalDistanceOrdering","text":"struct InternalDistanceOrdering <: KnrOrderingStrategy end\n\nUsed as ordering parameter of KnrIndex specifies that the internal distance of the underlying inverted index will be used to ordering the k nearest neighbors. Useful when the internal distance is quite representative of the real distance metric or whenever speed is the major objective.\n\n\n\n\n\n","category":"type"},{"location":"#NeighborhoodApproximationIndex.KnrCaches","page":"Home","title":"NeighborhoodApproximationIndex.KnrCaches","text":"struct KnrCaches\n    enc\nend\n\nCaches used for KnrIndex (one per thread)\n\nProperties\n\nenc: KnnResult for encoding purposes\n\n\n\n\n\n","category":"type"},{"location":"#NeighborhoodApproximationIndex.KnrIndex","page":"Home","title":"NeighborhoodApproximationIndex.KnrIndex","text":"struct KnrIndex <: AbstractSearchContext\n\nThe K nearest references inverted index\n\nParameters\n\ndist: the distance function of the index\ndb: the database of indexed objects\ncenters: a search index for a set of references\ninvfile: an inverted file data structure\nkbuild: the number of references to be computed and stored by each indexed object\nordering: specifies how the index performs final k nn selection\nopt: the parameters to be optimized by optimize!\n\n\n\n\n\n","category":"type"},{"location":"#NeighborhoodApproximationIndex.KnrIndex-Tuple{Distances.SemiMetric, SimilaritySearch.AbstractDatabase}","page":"Home","title":"NeighborhoodApproximationIndex.KnrIndex","text":"KnrIndex(\n    dist::SemiMetric,\n    db::AbstractDatabase;\n    invfiletype=BinaryInvertedFile,\n    invfiledist=JaccardDistance(),\n    initial=:dnet,\n    maxiters=0,\n    refs=references(dist, db; initial),\n    centers=nothing,\n    kbuild=3,\n    ksearch=1,\n    centersrecall::AbstractFloat=length(db) > 10^3 ? 0.95 : 1.0,\n    ordering=DistanceOrdering(),\n    pools=nothing,\n    parallel_block=get_parallel_block(length(db)),\n    verbose=false\n)\n\nA convenient function to create a KnrIndex, it uses several default arguments. After the construction, use optimize! to adjust the index to some performance.\n\nArguments\n\ndist: Distance object (a SemiMetric object, see Distances.jl)\ndb: The database of objects to be indexed. \n\nKeyword arguments\n\ninvfiletype: the type of the underlying inverted file (BinaryInvertedFile or WeightedInvertedFile)\ninvfiledist: the distance of the underlying inverted file (see InvertedFiles.jl package)\ncenters: The index used for centers/references, if centers === nothing then a sample of db will be used.\ninitial: indicates how references are selected, only used if refs will be computed; see references for more detail.\nmaxiters: how many iterations of the Lloyd algorithm are applied to initial references, only used if refs will be computed; see references for more detail.\nrefs: the set of reference, only used if centers === nothing\ncentersrecall: used when centers === nothing; if centersrecall == 1 then it will create an exact index on refs or an approximate if 0 < centersrecall < 1\nkbuild: the number of references to compute and store on construction\nksearch: the number of references to compute on searching\nordering: the ordering strategy\npools: an object with preallocated caches specific for KnrIndex, if pools=nothing it will use default caches.\nparallel_block Parallel construction works on batches, this is the size of these blocks\nverbose true if you want to see messages\n\n\n\n\n\n","category":"method"},{"location":"#Base.append!-Tuple{KnrIndex, Any}","page":"Home","title":"Base.append!","text":"append!(idx::KnrIndex, db; <kwargs>)\n\nAppends all items in the database db into the index\n\nArguments\n\nidx: the index structure\ndb: the objects to be appended\n\nKeyword arguments\n\nparallel_block: the number of elements to be inserted in parallel\npools: unused argument\nverbose: controls the verbosity of the procedure\n\n\n\n\n\n","category":"method"},{"location":"#Base.push!-Tuple{KnrIndex, Any}","page":"Home","title":"Base.push!","text":"push!(idx::KnrIndex, obj; pools=getpools(idx), encpools=getpools(idx.centers))\n\nInserts obj into the indexed\n\n\n\n\n\n","category":"method"},{"location":"#NeighborhoodApproximationIndex.get_parallel_block-Tuple{Any}","page":"Home","title":"NeighborhoodApproximationIndex.get_parallel_block","text":"get_parallel_block(n)\n\nAn heuristic to compute the parallel_block with respect with the number of elements to insert\n\n\n\n\n\n","category":"method"},{"location":"#NeighborhoodApproximationIndex.references-Tuple{Distances.SemiMetric, Any}","page":"Home","title":"NeighborhoodApproximationIndex.references","text":"references(dist::SemiMetric, db; <kwargs>) -> SubDatabase\n\nComputes a set of references, a sample of db, using the KCenters specification, it is a wrapper to kcenters function in the KCenters.jl package. The set of references are computed taking into account the specified r but also the distance function dist.\n\nArguments\n\ndist: a distance function\ndb: the database to be sampled\n\nKeyword arguments\n\nk::Int: the number of centers to compute, defaults to sqrt(|db|)\nsample::Real: indicates the sampling size before computing the set of k references, defaults to log(|db|) k; sample=0 means for no sampling.\nmaxiters::Int: number of iterationso  of the Lloyd algorithm that should be applied on the initial computation of centers, that is, maxiters > 0 applies maxiters iterations of the algorithm.\ntol::Float64: change tolerance to stop the Lloyd algorithm (error changes smaller than tol among iterations will stop the algorithm)\ninitial: initial centers or a strategy to compute initial centers, symbols :rand, :fft, and :dnet.\n\nThere are several interactions between initial values and parameter interactions (described in KCenters object), for instance, the maxiters > 0 apply the Lloyd's algorithm to the initial computation of references.\n\nif initial=:rand:\nmaxiters = 0 will retrieve a simple random sampling\nmaxiters > 0' achieve kmeans-centroids,maxiters` should be set appropiately for the the dataset\nif initial=:dnet:\nmaxiters = 0 computes a pure density-net\nmaxiters > 0 will compute a kmeans centroids but with an initialization based on the dnet\nif initial=:fft:\nmaxiters = 0 computes k centers with the farthest first traversal algorithm\nmaxiters > 0 will use the FFT based kcenters as initial points for the Lloyd algorithm\n\nNote 1: maxiters > 0 needs to compute centroids and these centroids should be defined for the specific data model, and also be of use in the specific metric distance and error function.\n\nNote 2: The error function is defined as the mean of distances of all objects in db to its associated nearest centers in each iteration.\n\nNote 3: The computation of references on large databases can be prohibitive, in these cases please consider to work on a sample of db\n\n\n\n\n\n","category":"method"},{"location":"#SimilaritySearch.index!-Tuple{KnrIndex}","page":"Home","title":"SimilaritySearch.index!","text":"index!(idx::KnrIndex; parallel_block=get_parallel_block(length(idx.db)), pools=nothing, verbose=true)\n\nIndexes all non indexed items in the database\n\nArguments\n\nidx: the index structure\n\nKeyword arguments\n\nparallel_block: the number of elements to be inserted in parallel\npools: unused parameter\nverbose: controls verbosity of the procedure\n\n\n\n\n\n","category":"method"},{"location":"#SimilaritySearch.search-Tuple{KnrIndex, Any, SimilaritySearch.KnnResult}","page":"Home","title":"SimilaritySearch.search","text":"search(idx::KnrIndex, q, res::KnnResult; ksearch=idx.opt.ksearch, ordering=idx.ordering, pools=getpools(D))\n\nSearches nearest neighbors of q inside the index under the distance function dist.\n\n\n\n\n\n","category":"method"}]
}
